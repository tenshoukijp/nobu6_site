%(hilight)s
<div class="content-box mb-3 content-lighten">
    <h2><i class="fa fa-lightbulb-o fa-fw"></i>ScenarioModVer2 更新履歴 v2.0.0.0～v2.3.0.0</h2>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.8 ⇒ v2.2.2.9</h3>
    <ul>
        <li><b>On_戦闘コマンド表示直前《戦争画面》(int 武将番号)</b> イベントハンドラや、<br>
        <li><b>On_基本コマンド表示直前《戦争画面》(int 武将番号)</b> イベントハンドラが、<br>
            正しく動いていない不具合の修正。 TSMod.dll のバージョンが 2.3.0.2 以上であること。
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.8 ⇒ v2.2.2.8 (ScenarioModは更新されていない)</h3>
    <ul>
        <li><b>On_職業名表示直前(int 武将番号)</b> イベントハンドラに関して、<br>
            これまであった「職業名称を変更可能な武将は、有効な職業である者(=「職業::無し」以外の武将)に限定される<br>
            という条件が撤廃された。<br>
            TSMod.dll のバージョンが 2.2.5.0 以上であること。
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.7 ⇒ v2.2.2.8</h3>
    <ul>
        <li>ScenarioModで、ゲーム起動時に、乱数の種である。srandを実行するようにした。<br>
            よって、乱数などを使う際には、原則的には、srandを使う必要はなく、rand関数のみで乱数が得られるはずである。

        <li>城の「位置」に関する情報について、幅広く得られるようにした。 <b>城グリッド位置型, Get_城グリッド位置, 城グリッド方向型 </b> などがある。<br>

            これらは下記の利用例を見るのがわかりやすいだろう。
            <div class="code">
                <pre class="brush:cpp;">
 string カスタム::On_噴出メッセージ直前(string 武将名, string 元メッセージ, メッセージ関連情報型 メッセージ関連情報) {

    int i = Get_城番号【配列用】(&quot;観音寺&quot;);
    城グリッド位置型 位置i = Get_城グリッド位置(i);

    デバッグ出力 &lt;&lt; i &lt;&lt; endl;
    デバッグ出力(&quot;観音寺：(X,Y):(%d,%d)&quot;, 位置i.Ｘ, 位置i.Ｙ);

    int j = pターン情報.現在のターン【城番号】-1;
    城グリッド位置型 位置j = Get_城グリッド位置(j);

    デバッグ出力 &lt;&lt; j &lt;&lt; endl;
    デバッグ出力(&quot;%s:(X,Y):(%d,%d)&quot;, Get_城名(j).c_str(), 位置j.Ｘ, 位置j.Ｙ);

    デバッグ出力 &lt;&lt; 位置j.北西【城番号】 &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.北【城番号】   &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.北東【城番号】 &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.西【城番号】   &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.東【城番号】   &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.南西【城番号】 &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.南【城番号】   &lt;&lt; endl;
    デバッグ出力 &lt;&lt; 位置j.南東【城番号】 &lt;&lt; endl;


    城グリッドベクトル型 my方角;
    my方角 = 位置i - 位置j;
    デバッグ出力(&quot;観音寺⇒プレイヤターン城は (Vx,Vy):(%d,%d)の方向にある。&quot;, my方角.Ｘ, my方角.Ｙ);

</pre>
            </div>

        <li><b>On_戦争開始(戦争開始パラメタ型 パラメタ) 関数にて、<br>
                「パラメタ.城番号」が渡ってくる</b>ことも注目点だろう。<br>
            この城番号とは、攻められた側の城、即ち、戦場の真ん中の城を指すわけであるから、<br>
            上の城位置情報と組み合わせることで、<br>
            今起きている、戦争画面に存在する城番号や城名、そして、９分割上での位置(北西の城とか)がわかるのである。<br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.6 ⇒ v2.2.2.7</h3>
    <ul class="pointlist">
        <li>
            <h4>On_職業名表示直前(int 武将番号)</h4>
            というイベントハンドラが加えられた。<br>
            使い方は、「On_噴出メッセージ直前」とほぼ同じである。
            <div class="code">
                <pre class="brush:cpp;">
string カスタム::On_職業名表示直前(int 武将番号) {

  int i武将顔番号 = p武将戸籍情報[武将番号-1].顔番号;

  if ( i武将顔番号 == 1322 ) {
    return &quot;占い師&quot;;
  }

  // 変更しない場合は何も返さない
  return &quot;&quot;;
}

</pre>
            </div>
            このように、今｢職業」を表示しようしている「武将番号」が引数として渡ってくるので、<br>
            メッセージの置き換え同様に、その時の様々な状況等判定して、職業名を返せば良い。<br>

            通常は顔番号や名前で判定して、職業名を返すだろう。<br>
            その瞬間の能力値等を判定して、職業名を変化させる、といった凝ったことも可能であるし、<br>
            所属している地域によって、変化させるといったことも当然可能である。<br>
            <br>
            ただし、もともと有効な職業(=「職業::無し」以外)に付いている必要があるので、注意すること。<br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.5 ⇒ v2.2.2.6</h3>
    <p>動画再生関数に関して、２番目の引数の仕様を変更した。</p>
    <ul class="pointlist">
        <li>
            <h4>動画再生("動画名", オプション)</h4>
            <br>
            以下のように利用する。
            <div class="code">
                <pre class="brush:cpp;">
    動画再生(&quot;KOEILOGO&quot;); // KOEILOGO.AVI を黒バックで再生する。黒バック付がデフォルトの挙動。

    動画再生(&quot;MYMOVIE&quot;, 動画::黒背景ＯＦＦ); // MYMOVIE.AVI(という自分で用意したAVI)を、黒バックにせずに、再生する。

    動画再生(&quot;HOGEHOGE&quot;, 動画::ＢＧＭ継続); // HOGEHOGE.AVI(という自分で用意したAVI)を、再生する。再生する際に、それまで流れているＢＧＭを停止せずに継続したままとする。

    動画再生(&quot;MYHOGE&quot;, 動画::黒背景ＯＦＦ|動画::ＢＧＭ継続); // MYHOGE.AVI(という自分で用意したAVI)を、再生する。
                                                             // 再生する際に、黒バックにせずに、かつ、それまで流れているＢＧＭを停止せずに継続したままとする。
</pre>
            </div>
    </ul>

</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.4 ⇒ v2.2.2.5</h3>
    <ul class="pointlist">
        <li>
            <h4>動画再生("動画名", 黒バック)</h4>
            という関数を追加した。<br>
            これは、文字通り、動画を再生するものである。<br>
            元々存在する動画でも良いし、自作した新しい動画を、ローカルハードディスクのmovieフォルダに入れたものでも良い。<br>
            以下のように利用する。
            <div class="code">
                <pre class="brush:cpp;">
    動画再生(&quot;KOEILOGO&quot;); // KOEILOGO.AVI を黒バックで再生する。黒バック付がデフォルトの挙動。

    動画再生(&quot;MYMOVIE&quot;, FALSE); // MYMOVIE.AVI(という自分で用意したAVI)を、黒バックにせずに、再生する。
</pre>
            </div>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.2 ⇒ v2.2.2.4</h3>
    <ul class="pointlist">
        <li>
            <h4>On_戦争開始(戦争開始パラメタ型 パラメタ)</h4>
            というイベントハンドラを追加した。<br>
            これは、文字通り、戦争が開始された時に、このイベントハンドラが実行される。<br>
            PC/NPC、戦場見る/見ないなどは無関係に実行される。<br>
            PC戦闘の場合は、戦前交渉が終わり、実際の戦場画面に入る直前をもって、戦闘開始とみなす。<br>
            引数である｢パラメタ｣には、ターゲットとなった｢城番号｣や、守備側の｢軍団番号・軍団長の武将番号｣、攻撃側の｢軍団番号・軍団長の武将番号｣などが渡ってくる。<br>
        <li>
            <h4>On_戦争終了()</h4>
            というイベントハンドラを追加した。<br>
            これは、文字通り、戦争が終了した時に、このイベントハンドラが実行される。<br>
            PC/NPC、戦場見る/見ないなどは無関係に実行される。<br>
            PC戦闘の時は、戦後の登用・斬首・解放等の処理が終わった時点をもって、戦争終了とみなす。<br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.2.0 ⇒ v2.2.2.2</h3>
    <ul>
        <li><b>基本::On_技能コマンド表示直前《戦争画面》 は</b>、<br>
            基本::On_基本コマンド表示直前《戦争画面》 と同じであるため、<b>削除</b>した。
        <li>戦闘画面における、自ユニットコマンド実行時の｢コマンド名｣を条件によって変更できるようにした。<br>
            考え方は、武将の吹き出しメッセージの置き換えと概ね同じで、｢コマンド名を表示しようとする度に｣、このイベントハンドラが呼ばれる。<br>
            よって、武将番号や、武将能力、所持家宝等の条件を判定して、コマンド名を変更する。 <br>
            <div class="code">
                <pre class="brush:cpp;">
void カスタム::On_戦闘コマンド表示直前《戦争画面》(int 武将番号) {
    if (武将番号==189) {
       Set_コマンド名( 戦争画面::戦闘コマンド名::通常攻撃, &quot;My攻撃&quot;);
       Set_コマンド名( 戦争画面::戦闘コマンド名::鉄砲攻撃, &quot;レーザー超魚雷&quot;);
    }
}</pre>
            </div>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">

    <h3>v2.2.1.0 ⇒ v2.2.2.0</h3>
    <ul>
        <li><b>正規表現</b>エンジンを鬼車に切り替えた。<br>
            これは、現在、日本語向けとしては、最高峰の正規表現エンジンである。<br>
            <br>
            使い方は、変わっていない。<b>Is_正規表現マッチ</b> や <b>正規表現マッチ結果型</b> を利用して使う。<br>
            ただし、利用可能な正規表現自体は相当増えている。<br>
            <br>
            詳しく知りたい人や、正規表現の熟練者は <a href="https://github.com/kkos/oniguruma/blob/master/doc/RE.ja">鬼車の正規表現</a> 参照のこと。<br>
            原則的に、PerlやRubyの正規表現と同等である。<br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">

    <h3>v2.2.0.8 ⇒ v2.2.1.0</h3>
    <ul>
        <li><b>正規表現</b>による文字列判定が可能となった。<br>
            これにより、事前に決め打ちできないメッセージをあいまいなまま取り扱うことが出来るようになった。<br>
            また、部分的にマッチした文字列を抽出することも格段にしやすくなった。<br>
            <br>
            以下のように利用する。<br>

            <ul>
                例①:
                <br>
                <div class="code">
                    <pre class="brush:cpp;">
    if (Is_正規表現マッチ(元メッセージ, &quot;米を.+?ほど\\s売&quot;)) {
        デバッグ出力 &lt;&lt; 元メッセージ &lt;&lt; endl;
    }</pre>
                </div>
                <br>
                例②
                <div class="code">
                    <pre class="brush:cpp;">
    if (Is_正規表現マッチ(元メッセージ, &quot;^他.+[米馬鉄砲]+を[0-9]+ほど\\s売&quot; )) {
        デバッグ出力 &lt;&lt; 元メッセージ &lt;&lt; endl;
    }</pre>
                </div>
                <br>
                例③:詳細なマッチ結果を得る
                <ul>
                    <li>｢<b>正規表現マッチ結果型</b> ｣ の変数を用意すると、 (下の例なら｢マッチ結果｣という変数名) <br>
                        詳細なマッチ情報が得られる。
                </ul>
                <ul>
                    <li>マッチ結果[1]のように番号でアクセスする。中身は文字列。 <br>
                    <li>０番目がマッチした部分の文字列全体。 <br>
                    <li>１番目以降が( )でくくった部分にマッチした文字列が順次格納される。 <br>
                    <li>存在しない｢番号｣にアクセスした場合は、空の文字列相当である｢""｣が返ってくる。
                </ul>
                <div class="code">
                    <pre class="brush:cpp;">
        正規表現マッチ結果型 マッチ結果;
        if ( Is_正規表現マッチ(元メッセージ, &quot;\\s(.+)を(\\d+?)ほど&quot;, &amp;マッチ結果 ) ) {
            デバッグ出力 &lt;&lt; マッチ結果[0] &lt;&lt; &quot;:&quot; &lt;&lt; マッチ結果[1] &lt;&lt; &quot;:&quot;  &lt;&lt; マッチ結果[2] &lt;&lt;  endl;
        }
</pre>
                </div>
                この例であれば、元のメッセージが｢｢他でもない[改行]米を1100ほど[改行]売りたいのじゃ｣というメッセージだった場合、
                <ul>
                    <li>マッチ結果[0]は、｢[改行]米を1100ほど｣となる。
                    <li>マッチ結果[1]は、1番目の( )の中身なので、｢米｣となり、
                    <li>マッチ結果[2]は、2番目の( )の中身なので、｢1100｣となる。
                </ul>
            </ul>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.0.7 ⇒ v2.2.0.8</h3>
    <ul class="pointlist">
        <li>
            <h4>デバッグ出力</h4>
            について、２つの記法でModDebuggerに出力できるようにした。<br>
            <ul class="arrowlist">
                <li>
                    <h5>C言語風</h5>
                    <b>printf(format, ...)</b> と、完全に同一の記法となる。 <br>
                    即ち、
                    <div class="code">
                        <pre class="brush:cpp;">デバッグ出力("%d,%s\n", 3, 元メッセージ.c_str())</pre>
                    </div>
                    のような記法。 <br>
                    (※こちらの記法で注意すべきは、printfのフォーマット指定子は｢string型｣をサポートしていないので、 <br>
                    string型については、c_str()すること。)
                <li>
                    <h5>C++のcout風</h5>
                    C++のcout &lt;&lt; ...と、完全に同一の記法となる。<br>
                    cout で利用可能な記法やマニピュレータは原則全て利用可能である。即ち、<br>
                    <div class="code">
                        <pre class="brush:cpp;">デバッグ出力 &lt;&lt; (int)メッセージ関連情報.第１人称【武将番号】 &lt;&lt; &quot;,&quot; &lt;&lt; 元メッセージ &lt;&lt; endl</pre>
                    </div>
                    のような記法となる。<br>
                    (※こちらの記法で注意すべきは、cout 同様、数値型は(int)でキャストしておくこと。又、基本的には、endlを付けることになります。endl(もしくはデバッグ出力.flush()したタイミングで出力されます。)
                <li>これらのデバッグ情報は、ModDebugger.exeを起動しておくことで、見ることが可能である。
            </ul>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.0.5 ⇒ v2.2.0.7</h3>
    <ul class="pointlist">
        <li>
            <h4>int カスタム::On_メインゲーム開始()</h4>
            というイベントハンドラは利用価値が高いため、｢カスタム｣クラス側にもデフォルトで用意された。<br>
        <li>
            <h4>void デバッグ出力(char *format, ...)</h4>
            を追加。ModDebuggerによって、Mod全体をデバッグしやすくする仕組み。<br>
            formatは書式化文字列であるため、この｢デバッグ出力｣関数の使い方は、C言語のprintf関数と同じである。
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.0.2 ⇒ v2.2.0.5</h3>
    <ul class="pointlist">
        <li>
            <h4>void カスタム::初期化()</h4>
            というイベントハンドラを追加。ゲーム起動時に実行される。<br>
        <li>
            <h4>BOOL 関数::Set_効果音ＤＬＬ追加(string 効果音ＤＬＬ名)</h4>
            という関数を追加。 又<br>
        <li>
            <h4>BOOL 効果音再生( int 効果音音源, string 効果音ＤＬＬ名="" )</h4>
            というように、第２引数として効果音用ＤＬＬを指定することが出来るようにした。<br>
            ｢Set_効果音ＤＬＬ追加」で事前にDLLを追加しておけば、<br>
            この第２引数に同じDLL名を指定することで、有効に機能する。<br>
            (※第２引数のＤＬＬ名を指定しない場合の挙動は従来通りである)<br>
            <br>
            使い方:
            <ul>
                <li>カスタム::初期化()イベントハンドラ内にて、効果音用のDLLを呼び出す。<br>
                    <div class="code">
                        <pre class="brush:cpp;">
void カスタム::初期化() {
    Set_効果音ＤＬＬ追加(&quot;my_se1.dll&quot;); // dllの名前はなんでも良い。
    Set_効果音ＤＬＬ追加(&quot;my_se2.dll&quot;); // 複数の効果音用のdllが登録可能。
}
</pre>
                    </div>
                <li>実際にどこかで鳴らす。<br>
                    <div class="code">
                        <pre class="brush:cpp;">
効果音再生( 3, &quot;my_se1.dll&quot;); // my_se1.dll内にある、 ｢3｣というリソース名が付いたWAV音を鳴らす。
効果音再生(20, &quot;my_se2.dll&quot;); // my_se2.dll内にある、｢20｣というリソース名が付いたWAV音を鳴らす。
効果音再生( 3, &quot;my_se2.dll&quot;); // my_se2.dll内にある、 ｢3｣というリソース名が付いたWAV音を鳴らす。
</pre>
                    </div>
                <li>効果音用DLLの作り方①
                    <ul class="pointlist">
                        <li>フル効果音キットを導入しているならば、「n6pwav1.dll」を、<br>
                            導入していないならば、「n6pwav.dll」を適当な名前でコピー。<br>
                            ここでは｢my_se1.dll」という名前にコピーしたと仮定する。
                        <li><a href="http://www.geocities.jp/donut1817/tabbrowser/misc/reshacker_outline.html">リソースハッカー</a>などを使って、my_se1.dllを開き編集する。<br>
                            リソースハッカーでリソースの名前を変更するのはわかりにくいと思うが、<br>
                            下図の1041(これは言語番号であるが…)を右クリックして、リソースの名前を変更すれば良い。<br>
                            <img src="./cnt_mod/mod_snmod/cnt_mod_scenario_mod_41.png"><br>
                            適当に操作していれば、そのうちリソース追加の方法や置き換え方法もわかるだろう。<br>
                    </ul>
                <li>効果音用DLLの作り方②
                    <p>他、新規にDLLのリソースパックを作る方法は「<a href="?page=nobu_mod_the_snmod_resource_pack">複数の効果音･画像を１つのDLLに</a>」にて詳細に解説している。</p>
            </ul>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.2.0.2 ⇒ v2.2.0.4</h3>
    <ul>
        <li><b>int カスタム::On_カスタム条件(string 条件名, カスタム条件パラメタ型パラメタ);</b><br>
            について、条件を変更しない時には、-1を返すように変更した。 <br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.1.0.2 ⇒ v2.2.0.2</h3>
    <ul class="pointlist">
        <li>
            <h4>On_相場変更直前()</h4>
            という駆動イベントハンドラを追加。<br>
            <br>
            これは相場が変更されるタイミング、<br>
            即ち、季節と季節の切り替わり目、｢相場が変更される直前｣に 呼び出されることとなる。<br>
            このイベントハンドラの中では以下の４つの関数を用いて相場を強制指定することが可能である。<br>
            <ul>
                <li>Set_米相場(int 米相場);
                <li>Set_鉄砲相場(int 鉄砲相場);
                <li>Set_馬相場(int 馬相場);
                <li>Set_兵相場(int 兵相場);
            </ul>
            それ以外にも、このイベントハンドラはプレイ全てを通して、季節の頭に必ず1回だけ安定して実行される、<br>
            という、わかりやすい駆動性質を持つため、重宝するだろう。(セーブ・ロードで実行が重複したりしない)
        <li>
            <h4>On_残りターン変化《戦争画面》(int 残りターン数)</h4>
            という駆動イベントハンドラを追加。<br>
            <br>
            これはその名の通り、残りターン数(30から減ってゆくもの)ターンが変化する境界時に呼び出される。 残りターン数には、そのまま残りターン数の数値が渡ってくる。<br>
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.1.0.0 ⇒ v2.1.0.2</h3>
    <ul class="pointlist">
        <li>武将情報系に、武将年齢を得るための関数として、<br>
            <h4>int Get_武将年齢(int 武将番号【配列用】)</h4>
            を追加。<br>
            <br>
        <li>Is_プレイヤ武将、Isプレイヤ軍団と類似の関数として、<br>
            <h4>Is_プレイヤ担当大名( WORD 大名番号【配列用】 )</h4>
            を追加。<br>
            <br>
        <li>基礎/カスタム駆動イベントハンドラとして、<br>
            <h4>int カスタム::On_カスタム条件(string 条件名, カスタム条件パラメタ型 パラメタ)</h4>
            を追加。<br>
            この関数は、TSMod等で定めている条件に対して、別の条件をORで加えたり、ANDで加えたりするものである。<br>
            詳細は、<a href="?page=nobu_mod_the_snmod_methodref_index">リファレンス</a>にて。
    </ul>
</div>
<div class="content-box mb-3 content-lighten">
    <h3>v2.0.0.5 ⇒ v2.1.0.0</h3>
    <ul class="pointlist">
        <li>
            <h4>関数という名前空間</h4>
            ｢○○情報型系｣の、通常のAPIは全て｢関数｣という名前空間に収まった。 <br>
            それに伴い、基礎駆動関数.hにて、｢using namespace 関数｣されている。 <br>
            <br>
            これにより、 ｢基本駆動関数｣や｢カスタム駆動関数｣の中では、 <br>
            ｢関数::｣というのは、付けても付けなくても良くなった。 <br>
            又、関数::と入力することで、インテリセンスが働き、存在するAPIを一覧しやすくなった。 <br>
        <li>
            <h4>同盟系のAPI</h4>
            が加わっている。今のところは大名情報型 のファイルの中に入っている。<br>
        <li>
            <h4>音楽再生系のAPI</h4>
            が加わっている。
        <li>
            <h4>Get_武将番号【配列用】(武将姓名)</h4>
            というAPIが加わった。<br>
        <li>
            <h4>戦場情報型のAPI</h4>
            が加わった。<br>
            現在野戦か、攻城戦か、攻城戦ならば城番号は何番か、などが得られるようになった。<br>
        <li>
            <h4>その他</h4>
            いくつかの不適切な変数名・関数名が修正されている。<br>
            <br>
            例:
            <ul>
                <li>効果音素材::突 ⇒ 効果音素材::突撃
                <li>GET_軍団役職 ⇒ Get_軍団役職
                <li>城情報型::所属大名【大名番号】 ⇒ 城情報型::所属軍団【軍団番号】
            </ul>
    </ul>
</div>